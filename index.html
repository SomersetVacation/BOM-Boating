<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Boating Conditions</title>

<style>
  body { margin:0; background:black; color:white; font-family:Arial, Helvetica, sans-serif; }
  .card{ border:1px solid #333; border-radius:14px; padding:14px; background:rgba(255,255,255,0.06); max-width:420px; margin:0 auto; }
  h2 { margin:0 0 8px; font-size:22px; text-align:center; }
  .subhead{ display:flex; justify-content:space-between; margin-bottom:8px; font-size:13px; opacity:.85; }
  .sectionTitle{ margin:10px 0 8px; font-size:14px; font-weight:900; opacity:.9; }
  .stack{ display:flex; flex-direction:column; gap:10px; }
  .slot{ border:1px solid #2a2a2a; border-radius:12px; padding:10px; background:rgba(0,0,0,0.18); }
  .slotTop{ display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
  .slotTime{ font-size:15px; font-weight:800; }
  .badge{ font-size:11px; font-weight:900; padding:3px 8px; border-radius:999px; border:1px solid currentColor; flex:0 0 auto; }
  .kv{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 10px; font-size:13px; line-height:1.25; }
  .cell{ display:flex; gap:6px; align-items:baseline; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .k{ opacity:.70; font-size:12px; font-weight:700; flex:0 0 auto; }
  .v{ font-weight:800; flex:1 1 auto; min-width:0; }
  .good { color:#8fff9a; }
  .ok   { color:#ffd27d; }
  .bad  { color:#ff9a9a; }
  .legend{ margin-top:10px; padding:10px; border:1px solid #2a2a2a; border-radius:12px; background:rgba(0,0,0,0.18); font-size:12px; line-height:1.35; }
  .legend .row{ margin-top:6px; }
  .legend .tag{ display:inline-block; padding:2px 7px; border-radius:999px; border:1px solid currentColor; font-weight:900; font-size:11px; margin-right:6px; }
  .meta{ margin-top:10px; padding-top:8px; border-top:1px solid #222; font-size:12px; opacity:.75; text-align:center; }
  .meta a{ color:#9fd4ff; text-decoration:none; }
</style>
</head>

<body>
<div class="card">
  <h2>Boating Conditions</h2>

  <div class="subhead">
    <div>Somerset</div>
    <div id="nowLine">–</div>
  </div>

  <div class="sectionTitle">Today</div>
  <div id="slotsToday" class="stack"></div>

  <div class="sectionTitle">Tomorrow (best 3h window)</div>
  <div id="slotTomorrowBest" class="stack"></div>

  <div class="legend">
    <div><strong>Rating guide</strong></div>
    <div class="row good"><span class="tag">GOOD</span>Wind/gust ≤ <strong>18 km/h</strong>, rain ≤ <strong>35%</strong></div>
    <div class="row ok"><span class="tag">OK</span>Wind/gust ≤ <strong>26 km/h</strong>, rain ≤ <strong>60%</strong></div>
    <div class="row bad"><span class="tag">BAD</span>Stronger wind/gust or high rain risk</div>
  </div>

  <div class="meta">
    <div id="metaUpdated">Last updated: –</div>
    <div id="metaNext">Next update: –</div>
    <div>
      Source: <a href="https://www.bom.gov.au/" target="_blank" rel="noopener">Bureau of Meteorology (BOM)</a>
    </div>
  </div>
</div>

<script>
const TZ  = "Australia/Brisbane";

// Your slot model (same as before)
const WINDOW_HOURS = 3;
const DAY_SLOTS = [
  { start: 6,  end: 9  },
  { start: 9,  end: 12 },
  { start: 12, end: 15 },
  { start: 15, end: 18 }
];

const REFRESH_MS = 30 * 60 * 1000;

// BOM endpoint base (unofficial-but-common)
const BOM_BASE = "https://api.weather.bom.gov.au/v1";

// Pick a stable search string for the lake area
const BOM_LOCATION_SEARCH = "Somerset Dam";

// 3-hourly forecast does not include gusts; estimate them
const GUST_FACTOR = 1.35;

// ---- helpers (yours + a few added) ----
function waveProxy(kmh){
  if (kmh < 5) return 0;
  if (kmh < 10) return 10;
  if (kmh < 15) return 20;
  if (kmh < 20) return 35;
  if (kmh < 25) return 50;
  return 70;
}

function fmtTime(d){
  return d.toLocaleTimeString("en-AU",{timeZone:TZ,hour:"2-digit",minute:"2-digit"});
}

function dayStr(offsetDays){
  return new Date(Date.now() + offsetDays*86400000).toLocaleDateString("en-CA",{timeZone:TZ});
}

function classify(e){
  const eff=Math.max(e.maxWind,e.maxGust);
  if(eff<=18 && e.maxProb<=35) return{label:"GOOD",cls:"good"};
  if(eff<=26 && e.maxProb<=60) return{label:"OK",cls:"ok"};
  return{label:"BAD",cls:"bad"};
}

/* lower score = better */
function score(e){
  return (e.avgWind*2.0) + (e.avgGust*3.0) + (e.maxProb*1.3) + (e.totalMm*80);
}

function windDir(dirStr){
  // BOM gives strings like "E", "ENE", "SE" already
  return (dirStr || "–");
}

function renderSlot(containerEl, labelPrefix, e){
  const c = classify(e);
  const s = e.slot;
  const eff = Math.max(e.maxWind, e.maxGust);
  const wave = waveProxy(eff);

  const el = document.createElement("div");
  el.className = `slot ${c.cls}`;
  el.innerHTML = `
    <div class="slotTop">
      <div class="slotTime">${labelPrefix} ${String(s.start).padStart(2,"0")}:00 – ${String(s.end).padStart(2,"0")}:00</div>
      <div class="badge">${c.label}</div>
    </div>

    <div class="kv">
      <div class="cell"><span class="k">Wind</span><span class="v">${e.avgWind.toFixed(0)} / ${e.maxWind.toFixed(0)} km/h (${windDir(e.dir)})</span></div>
      <div class="cell"><span class="k">Gust</span><span class="v">${e.avgGust.toFixed(0)} / ${e.maxGust.toFixed(0)} km/h</span></div>
      <div class="cell"><span class="k">Wave</span><span class="v">~${wave} cm</span></div>
      <div class="cell"><span class="k">Rain</span><span class="v">≤ ${e.maxProb}% · ${e.totalMm.toFixed(1)} mm</span></div>
    </div>
  `;
  containerEl.appendChild(el);
}

// ---- BOM wiring ----
async function bomSearchGeohash(){
  // /locations?search=...  (search must be >=3 chars)
  const url = `${BOM_BASE}/locations?search=${encodeURIComponent(BOM_LOCATION_SEARCH)}`;
  const r = await fetch(url, { cache:"no-store" });
  if(!r.ok) throw new Error(`BOM location search failed: HTTP ${r.status}`);
  const j = await r.json();

  const list = (j && j.data) ? j.data : [];
  if(!list.length) throw new Error(`No BOM locations found for "${BOM_LOCATION_SEARCH}"`);

  // Prefer exact-ish name match, else first result
  const best =
    list.find(x => (x.name || "").toLowerCase().includes("somerset")) ||
    list[0];

  return best.geohash; // e.g. "r3..."
}

async function bomFetch3Hourly(geohash){
  // 3-hourly uses "modified geohash" = remove last character
  const modified = geohash.slice(0, -1);
  const url = `${BOM_BASE}/locations/${encodeURIComponent(modified)}/forecasts/3-hourly`;
  const r = await fetch(url, { cache:"no-store" });
  if(!r.ok) throw new Error(`BOM 3-hourly failed: HTTP ${r.status}`);
  return r.json();
}

function toLocalDateHour(isoUtc){
  // Convert BOM UTC time string -> local Date -> dayStr + hour
  const d = new Date(isoUtc);
  const dateStr = d.toLocaleDateString("en-CA",{ timeZone: TZ });
  const hourStr = d.toLocaleTimeString("en-AU",{ timeZone: TZ, hour:"2-digit", hour12:false });
  const hour = parseInt(hourStr, 10);
  return { dateStr, hour };
}

function buildIndexFromBom3Hourly(items){
  // Index by `${dateStr}T${hh}:00`
  // so your existing “findIndexForDayHour” style mapping stays easy.
  const t = [];
  const wind = [];
  const gust = [];
  const dir = [];
  const prob = [];
  const mm = [];

  for(const it of items){
    const { dateStr, hour } = toLocalDateHour(it.time);
    const key = `${dateStr}T${String(hour).padStart(2,"0")}:00`;

    // wind speed in km/h
    const w = (it.wind && typeof it.wind.speed_kilometre === "number") ? it.wind.speed_kilometre : 0;

    // gust estimate
    const g = Math.round(w * GUST_FACTOR);

    // rain chance (%)
    const p = (it.rain && typeof it.rain.chance === "number") ? it.rain.chance : 0;

    // rain amount range - pick max if present else min else 0
    const amt = (it.rain && it.rain.amount) ? it.rain.amount : {};
    const mmVal =
      (typeof amt.max === "number") ? amt.max :
      (typeof amt.min === "number") ? amt.min :
      0;

    t.push(key);
    wind.push(w);
    gust.push(g);
    dir.push((it.wind && it.wind.direction) ? it.wind.direction : null);
    prob.push(p);
    mm.push(mmVal);
  }

  return { t, wind, gust, dir, prob, mm };
}

function findIndexForDayHour(t, dateStr, hour){
  const hh = String(hour).padStart(2,"0");
  return t.findIndex(x => x.startsWith(`${dateStr}T${hh}:00`));
}

function computeSlotMetrics(t, wind, gust, wd, prob, mm, dateStr, slot){
  // For BOM 3-hourly, each slot is exactly one item at slot.start.
  const idx = findIndexForDayHour(t, dateStr, slot.start);
  if(idx < 0) return null;

  // Treat this 3-hour block as the whole window
  const w = wind[idx] || 0;
  const g = gust[idx] || w;
  const p = prob[idx] || 0;
  const m = mm[idx] || 0;

  return {
    slot,
    avgWind: w,
    maxWind: w,
    avgGust: g,
    maxGust: g,
    maxProb: p,
    totalMm: m,
    dir: wd[idx]
  };
}

async function load(){
  const now=new Date();
  document.getElementById("nowLine").textContent=`Now: ${fmtTime(now)}`;

  let geohash, forecastJson;
  try{
    geohash = await bomSearchGeohash();
    forecastJson = await bomFetch3Hourly(geohash);
  } catch(err){
    // Show a friendly error on-screen (most common cause: CORS blocked by BOM)
    const todayWrap = document.getElementById("slotsToday");
    const tomWrap = document.getElementById("slotTomorrowBest");
    todayWrap.innerHTML = "";
    tomWrap.innerHTML = "";

    const el = document.createElement("div");
    el.className = "slot bad";
    el.innerHTML = `
      <div class="slotTop">
        <div class="slotTime">BOM data unavailable</div>
        <div class="badge">ERROR</div>
      </div>
      <div style="font-size:12px; line-height:1.35; opacity:.9">
        ${String(err.message || err)}<br><br>
        If this works on your Pi but not on your website, it’s usually a browser CORS restriction.
        In that case, use a tiny proxy (Cloudflare Worker / Netlify Function / AWS Lambda) to fetch BOM and add CORS.
      </div>
    `;
    todayWrap.appendChild(el);
    return;
  }

  const items = (forecastJson && forecastJson.data) ? forecastJson.data : [];
  const idx = buildIndexFromBom3Hourly(items);

  const today = dayStr(0);
  const tomorrow = dayStr(1);

  // TODAY
  const todayWrap = document.getElementById("slotsToday");
  todayWrap.innerHTML = "";
  for(const s of DAY_SLOTS){
    const e = computeSlotMetrics(idx.t, idx.wind, idx.gust, idx.dir, idx.prob, idx.mm, today, s);
    if(!e) continue;
    renderSlot(todayWrap, "", e);
  }

  // TOMORROW BEST
  const tomWrap = document.getElementById("slotTomorrowBest");
  tomWrap.innerHTML = "";

  let best = null;
  for(const s of DAY_SLOTS){
    const e = computeSlotMetrics(idx.t, idx.wind, idx.gust, idx.dir, idx.prob, idx.mm, tomorrow, s);
    if(!e) continue;
    const sc = score(e);
    if(!best || sc < best.sc) best = { e, sc };
  }

  if(best && best.e){
    renderSlot(tomWrap, "Best:", best.e);
  } else {
    const el = document.createElement("div");
    el.className = "slot";
    el.textContent = "No forecast data for tomorrow yet.";
    tomWrap.appendChild(el);
  }

  document.getElementById("metaUpdated").textContent =
    `Last updated: ${now.toLocaleString("en-AU",{timeZone:TZ})}`;
  document.getElementById("metaNext").textContent =
    `Next update: ${new Date(now.getTime()+REFRESH_MS).toLocaleTimeString("en-AU",{timeZone:TZ})}`;
}

load();
setInterval(load,REFRESH_MS);
</script>
</body>
</html>